<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Shot YOLO Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body { font-family: 'Inter', sans-serif; }
        #annotation-container {
            position: relative;
            display: inline-block;
            background-color: #222;
        }
        #annotation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }
        #reference-image {
            display: block;
            max-width: 100%;
            height: auto;
        }
        #video-stream {
            width: 100%;
            height: auto;
            max-height: 80vh;
            background-color: #111;
            border-radius: 0.5rem;
        }
        /* Simple spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .active-class {
            border-width: 2px;
            border-color: #3498db; /* blue-500 */
            background-color: #374151; /* gray-700 */
        }
        /* Styles for new capture gallery */
        #capture-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            background-color: #2d3748; /* gray-800 */
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
        #capture-gallery img {
            width: 100%;
            height: auto;
            border-radius: 0.25rem;
            border: 2px solid transparent;
            cursor: pointer;
        }
        #capture-gallery img.is-annotating {
            border-color: #3498db; /* blue-500 */
            box-shadow: 0 0 10px #3498db;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center p-4">

    <div class="w-full max-w-5xl mx-auto">
        <header class="flex justify-between items-center mb-4 p-4 bg-gray-800 rounded-lg shadow-lg">
            <h1 class="text-2xl font-bold text-white">Multi-Shot YOLO Trainer</h1>
            <button id="reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-all">
                Start Over
            </button>
        </header>

        <main class="bg-gray-800 rounded-lg shadow-lg p-6">
            
            <div id="step-capture" class="step-container">
                <h2 class="text-xl font-semibold mb-2">Step 1: Capture Reference Images</h2>
                <p class="mb-4 text-gray-400">Capture one or more images. When finished, click "Start Annotating".</p>
                <div class="mb-4 rounded-lg overflow-hidden shadow-inner">
                    <img id="video-stream-capture" src="" alt="Live Capture Feed" class="w-full h-auto bg-gray-700">
                </div>
                <div class="flex gap-4">
                    <button id="capture-button" class="flex-grow bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-all">
                        &#128248; Capture Photo
                    </button>
                    <button id="go-to-annotate-button" class="flex-grow bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-all disabled:bg-gray-500" disabled>
                        Start Annotating (0)
                    </button>
                </div>
                <h3 class="font-semibold mt-4 mb-2">Captured Images:</h3>
                <div id="capture-gallery">
                    <p class="text-gray-500">No images captured yet.</p>
                </div>
            </div>

            <div id="step-annotate" class="step-container hidden">
                <h2 id="annotate-heading" class="text-xl font-semibold mb-2">Step 2: Annotate Objects (Image 1 of 1)</h2>
                <p class="mb-4 text-gray-400">Add classes, then draw boxes. Use "Next/Prev" to switch images.</p>
                
                <div class="flex flex-col md:flex-row gap-4">
                    <div id="annotation-container" class="border-2 border-dashed border-gray-600 rounded-lg overflow-hidden flex-grow">
                        <img id="reference-image" src="" alt="Reference Image">
                        <canvas id="annotation-canvas"></canvas>
                    </div>
                    <div class="flex-shrink-0 w-full md:w-64">
                        <h3 class="font-semibold mb-2">Annotation Controls:</h3>
                        <div class="flex gap-2 mb-2">
                             <button id="prev-image-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">&larr; Prev</button>
                             <button id="next-image-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Next &rarr;</button>
                        </div>
                        <div class="mb-4">
                            <button id="undo-button" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg mb-2">Undo Last Box</button>
                            <button id="clear-boxes-button" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Clear All Boxes</button>
                        </div>
                        <h3 class="font-semibold mb-2">Object Types:</h3>
                        <button id="add-class-button" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg mb-3">
                            + Add New Class
                        </button>
                        <ul id="legend-list" class="bg-gray-700 p-3 rounded-lg text-sm space-y-2">
                            </ul>
                    </div>
                </div>

                <button id="train-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-all mt-6 disabled:bg-gray-500">
                    &#129504; Start Training
                </button>
            </div>

            <div id="step-training" class="step-container hidden text-center p-12">
                <div class="spinner mx-auto mb-6"></div>
                <h2 class="text-2xl font-semibold mb-2">Step 3: Training in Progress...</h2>
                <p class="text-gray-400">The model is being prompted with your annotations.</p>
                <p class="text-gray-500 text-sm mt-2">This may take a minute.</p>
            </div>

            <div id="step-detect" class="step-container hidden">
                <h2 class="text-xl font-semibold mb-2">Step 4: Live Detection</h2>
                <p class="mb-4 text-gray-400">The server is now running your custom model.</p>
                <div class="mb-4 rounded-lg overflow-hidden shadow-inner">
                    <img id="video-stream-detect" src="" alt="Live Detection Feed" class="w-full h-auto bg-gray-700">
                </div>
                <p class="text-center text-gray-500">To re-train, click "Start Over".</p>
            </div>

        </main>
    </div>

    <script>
        // --- DOM Elements ---
        const steps = {
            capture: document.getElementById('step-capture'),
            annotate: document.getElementById('step-annotate'),
            training: document.getElementById('step-training'),
            detect: document.getElementById('step-detect')
        };
        const videoStreamCapture = document.getElementById('video-stream-capture');
        const videoStreamDetect = document.getElementById('video-stream-detect');
        
        const captureButton = document.getElementById('capture-button');
        const goToAnnotateButton = document.getElementById('go-to-annotate-button');
        const trainButton = document.getElementById('train-button');
        const resetButton = document.getElementById('reset-button');
        const undoButton = document.getElementById('undo-button');
        const clearBoxesButton = document.getElementById('clear-boxes-button');
        const addClassButton = document.getElementById('add-class-button');
        const prevImageButton = document.getElementById('prev-image-button');
        const nextImageButton = document.getElementById('next-image-button');
        
        const refImage = document.getElementById('reference-image');
        const canvas = document.getElementById('annotation-canvas');
        const ctx = canvas.getContext('2d');
        const legendList = document.getElementById('legend-list');
        const captureGallery = document.getElementById('capture-gallery');
        const annotateHeading = document.getElementById('annotate-heading');

        // --- NEW App State ---
        let appState = 'CAPTURE';
        let classTypes = []; // { id, name, color }
        let activeClassId = 0;
        let drawnBoxes = []; // Boxes for the *current* image
        
        let capturedImages = []; // List of image filenames (e.g., "reference_0.jpg")
        let allAnnotations = {}; // Maps filename -> array of boxes
        let currentAnnotationImageIndex = 0;

        // --- Annotation State ---
        let isDrawing = false;
        let startPos = { x: 0, y: 0 };
        let mousePos = { x: 0, y: 0 }; 
        let imageOriginalSize = { w: 0, h: 0 };
        let imageRenderSize = { w: 0, h: 0 };

        const colors = [
            '#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#ecf0f1', '#95a5a6'
        ];

        // --- Utility Functions ---

        function showStep(stepName) {
            appState = stepName.toUpperCase();
            Object.keys(steps).forEach(key => {
                steps[key].classList.toggle('hidden', key !== stepName);
            });

            const timestamp = new Date().getTime();
            if (stepName === 'capture') {
                videoStreamCapture.src = `/video/capture_feed?t=${timestamp}`;
                videoStreamDetect.src = '';
            } else if (stepName === 'annotate') {
                videoStreamCapture.src = `/video/capture_feed?t=${timestamp}`; // Keep feed running
                videoStreamDetect.src = '';
                // Load the first image for annotation
                loadAnnotationImage(0);
            } else if (stepName === 'detect') {
                videoStreamDetect.src = `/video/detection_feed?t=${timestamp}`;
                videoStreamCapture.src = ''; 
            } else {
                videoStreamCapture.src = '';
                videoStreamDetect.src = '';
            }
            
            updateTrainButton();
        }

        async function checkServerStatus() {
            try {
                const response = await fetch('/api/status');
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                
                // Update state from server
                capturedImages = data.images || [];
                updateCaptureGallery();
                
                if (data.status === 'CAPTURE') {
                    showStep('capture');
                } else if (data.status === 'ANNOTATE') {
                    // If we reload on annotate step, go to capture
                    // A more complex app would save/load annotations
                    showStep('capture');
                } else if (data.status === 'TRAINING') {
                    showStep('training');
                } else if (data.status === 'DETECT') {
                    showStep('detect');
                }
            } catch (error) {
                console.error('Error checking server status:', error);
            }
        }
        
        function getScaledMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = imageOriginalSize.w / rect.width;
            const scaleY = imageOriginalSize.h / rect.height;

            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }
        
        // --- NEW: Gallery UI ---
        function updateCaptureGallery() {
            if (capturedImages.length === 0) {
                captureGallery.innerHTML = '<p class="text-gray-500">No images captured yet.</p>';
                goToAnnotateButton.disabled = true;
                goToAnnotateButton.innerText = 'Start Annotating (0)';
                return;
            }
            
            captureGallery.innerHTML = ''; // Clear
            capturedImages.forEach((filename, index) => {
                const img = document.createElement('img');
                img.src = `/generated/${filename}?t=${new Date().getTime()}`;
                img.alt = `Reference ${index}`;
                img.onclick = () => {
                    // Allow clicking gallery to jump to image in annotate step
                    if (appState === 'ANNOTATE') {
                        loadAnnotationImage(index);
                    }
                };
                // Highlight image being annotated
                if (appState === 'ANNOTATE' && index === currentAnnotationImageIndex) {
                    img.classList.add('is-annotating');
                }
                captureGallery.appendChild(img);
            });
            
            goToAnnotateButton.disabled = false;
            goToAnnotateButton.innerText = `Start Annotating (${capturedImages.length})`;
        }

        // --- NEW: Annotation Image Loading ---
        function loadAnnotationImage(index) {
            if (index < 0 || index >= capturedImages.length) return;
            
            // Save boxes for the *previous* image
            saveCurrentAnnotations();
            
            currentAnnotationImageIndex = index;
            const filename = capturedImages[index];
            
            console.log(`Loading image ${index}: ${filename}`);
            
            // Load new image
            refImage.src = `/generated/${filename}?t=${new Date().getTime()}`;
            refImage.onload = () => {
                // Get image size *before* initCanvas
                imageOriginalSize = { w: refImage.naturalWidth, h: refImage.naturalHeight };
                console.log(`Image ${filename} loaded with size ${imageOriginalSize.w}x${imageOriginalSize.h}`);
                initCanvas(); // This will also call drawAnnotations
            };

            // Load saved boxes for this image
            drawnBoxes = allAnnotations[filename] || [];
            
            // Update UI
            annotateHeading.innerText = `Step 2: Annotate Objects (Image ${index + 1} of ${capturedImages.length})`;
            prevImageButton.disabled = (index === 0);
            nextImageButton.disabled = (index === capturedImages.length - 1);
            updateCaptureGallery(); // Update highlighted thumbnail
            updateTrainButton();
        }
        
        // --- NEW: Save annotations for current image ---
        function saveCurrentAnnotations() {
            if (capturedImages.length === 0) return;
            const currentFilename = capturedImages[currentAnnotationImageIndex];
            if (currentFilename) {
                allAnnotations[currentFilename] = drawnBoxes;
                console.log(`Saved ${drawnBoxes.length} boxes for ${currentFilename}`);
            }
        }

        // --- Canvas Drawing Functions ---

        function initCanvas() {
            if (!refImage.src || !refImage.complete || imageOriginalSize.w === 0) {
                console.warn("Reference image not ready for canvas init.");
                return;
            }
            
            const rect = refImage.getBoundingClientRect();
            imageRenderSize = { w: rect.width, h: rect.height };
            
            canvas.style.width = `${imageRenderSize.w}px`;
            canvas.style.height = `${imageRenderSize.h}px`;
            canvas.width = imageOriginalSize.w;
            canvas.height = imageOriginalSize.h;
            
            console.log(`Canvas Initialized: Original(${imageOriginalSize.w}x${imageOriginalSize.h}), Render(${imageRenderSize.w}x${imageRenderSize.h})`);
            drawAnnotations();
        }

        function drawAnnotations() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const activeColor = classTypes.find(c => c.id === activeClassId)?.color || '#ffffff';

            drawnBoxes.forEach(box => {
                ctx.strokeStyle = box.color;
                ctx.lineWidth = 3;
                ctx.strokeRect(box.bbox[0], box.bbox[1], box.bbox[2] - box.bbox[0], box.bbox[3] - box.bbox[1]);
                
                ctx.fillStyle = box.color;
                ctx.font = '24px sans-serif';
                ctx.fillText(box.class_name, box.bbox[0] + 5, box.bbox[1] + 24);
            });

            if (isDrawing) {
                ctx.strokeStyle = activeColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(startPos.x, startPos.y, mousePos.x - startPos.x, mousePos.y - startPos.y);
                ctx.setLineDash([]);
            }
            
            ctx.strokeStyle = activeColor;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(mousePos.x, 0);
            ctx.lineTo(mousePos.x, canvas.height);
            ctx.moveTo(0, mousePos.y);
            ctx.lineTo(canvas.width, mousePos.y);
            ctx.stroke();
        }

        function updateLegend() {
            legendList.innerHTML = '';
            
            if (classTypes.length === 0) {
                 legendList.innerHTML = '<li class="text-gray-400">No object types added yet.</li>';
            }

            classTypes.forEach(cls => {
                const li = document.createElement('li');
                li.className = `flex items-center p-2 rounded-lg cursor-pointer bg-gray-800 hover:bg-gray-700 ${cls.id === activeClassId ? 'active-class' : ''}`;
                li.onclick = () => {
                    activeClassId = cls.id;
                    updateLegend();
                    drawAnnotations();
                };

                li.innerHTML = `
                    <span class="w-4 h-4 rounded-full mr-2 flex-shrink-0" style="background-color: ${cls.color}"></span>
                    <input 
                        type="text" 
                        value="${cls.name}" 
                        data-id="${cls.id}"
                        class="bg-transparent w-full focus:bg-gray-600 rounded px-1"
                        placeholder="Object Name"
                    >
                `;
                
                const input = li.querySelector('input');
                input.onclick = (e) => e.stopPropagation();
                
                input.onchange = (e) => {
                    const id = parseInt(e.target.dataset.id);
                    const newName = e.target.value;
                    const classToUpdate = classTypes.find(c => c.id === id);
                    if (classToUpdate) classToUpdate.name = newName;
                    
                    // Update all boxes in all annotations
                    Object.values(allAnnotations).flat().forEach(box => {
                        if (box.class_id === id) box.class_name = newName;
                    });
                    // And current drawnBoxes
                    drawnBoxes.forEach(box => {
                        if (box.class_id === id) box.class_name = newName;
                    });
                    drawAnnotations();
                };
                legendList.appendChild(li);
            });
        }
        
        function updateTrainButton() {
            // Must have at least one annotation, somewhere
            const totalAnnotations = Object.values(allAnnotations).flat().length + drawnBoxes.length;
            trainButton.disabled = totalAnnotations === 0;
        }

        // --- Canvas Event Handlers ---
        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (classTypes.length === 0) {
                window.alert("Please add an object type first!");
                return;
            }
            isDrawing = true;
            startPos = getScaledMousePos(e);
            mousePos = startPos;
            drawAnnotations();
        });

        canvas.addEventListener('mousemove', (e) => {
            mousePos = getScaledMousePos(e);
            drawAnnotations();
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;
            const endPos = getScaledMousePos(e);
            const box = [
                Math.min(startPos.x, endPos.x),
                Math.min(startPos.y, endPos.y),
                Math.max(startPos.x, endPos.x),
                Math.max(startPos.y, endPos.y)
            ];

            if (box[2] - box[0] < 5 || box[3] - box[1] < 5) {
                drawAnnotations();
                return;
            }

            const activeClass = classTypes.find(c => c.id === activeClassId);
            if (!activeClass) return;

            drawnBoxes.push({
                bbox: box.map(coord => Math.round(coord)),
                class_id: activeClass.id,
                class_name: activeClass.name,
                color: activeClass.color
            });

            drawAnnotations();
            updateTrainButton(); // Check if we can enable train
        });
        
        canvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                canvas.dispatchEvent(new MouseEvent('mouseup'));
            }
            mousePos = {x: -1, y: -1};
            drawAnnotations();
        });
        
        window.addEventListener('resize', initCanvas);

        // --- API Call Functions ---

        async function handleCaptureClick() {
            console.log("Capturing image...");
            try {
                const response = await fetch('/api/capture', { method: 'POST' });
                if (!response.ok) throw new Error('Failed to capture');
                
                const data = await response.json();
                console.log('Capture response:', data);
                
                // Update our state with the full list
                capturedImages = data.all_images;
                updateCaptureGallery();
            } catch (error) {
                console.error('Capture error:', error);
                window.alert('Failed to capture image. Check server logs.');
            }
        }
        
        async function handleTrainClick() {
            // Save final annotations
            saveCurrentAnnotations();
            
            // Check for empty class names
            if (classTypes.some(c => !c.name.trim())) {
                window.alert("Please make sure all object types have a name.");
                return;
            }
            
            // Check if any annotations exist
            const totalAnnotations = Object.values(allAnnotations).flat().length;
            if (totalAnnotations === 0) {
                 window.alert("Please draw at least one bounding box.");
                return;
            }
            
            console.log("Starting training with all annotations:", allAnnotations);
            console.log("With class types:", classTypes);

            showStep('training');

            // Prep data for server
            const classNames = classTypes.map(c => c.name.trim());
            
            // NEW: Clean the 'allAnnotations' object for sending
            // We only need bbox and class_id
            const annotationsForServer = {};
            for (const filename in allAnnotations) {
                annotationsForServer[filename] = allAnnotations[filename].map(b => ({
                    bbox: b.bbox,
                    class_id: b.class_id
                }));
            }

            try {
                const response = await fetch('/api/train', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        annotations: annotationsForServer, // Send the new object
                        class_names: classNames
                    })
                });
                
                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.error || 'Training request failed');
                }

                const data = await response.json();
                console.log('Training response:', data);
                
                if (data.status === 'DETECT') {
                    showStep('detect');
                } else {
                    window.alert('Training complete but status is not DETECT.');
                    showStep('annotate');
                }
            } catch (error)
            {
                console.error('Training error:', error);
                window.alert(`Training failed: ${error.message}`);
                showStep('annotate');
            }
        }

        async function handleResetClick() {
            console.log("Resetting application...");
            try {
                await fetch('/api/reset', { method: 'POST' });
                
                // Reset local state
                capturedImages = [];
                allAnnotations = {};
                drawnBoxes = [];
                classTypes = [];
                activeClassId = 0;
                currentAnnotationImageIndex = 0;
                
                updateLegend();
                updateCaptureGallery();
                
                showStep('capture');
            } catch (error) {
                console.error('Reset error:', error);
            }
        }

        // --- Button Event Listeners ---
        captureButton.addEventListener('click', handleCaptureClick);
        trainButton.addEventListener('click', handleTrainClick);
        resetButton.addEventListener('click', handleResetClick);
        
        goToAnnotateButton.addEventListener('click', () => {
            if (capturedImages.length > 0) {
                showStep('annotate');
            }
        });
        
        prevImageButton.addEventListener('click', () => {
            loadAnnotationImage(currentAnnotationImageIndex - 1);
        });
        
        nextImageButton.addEventListener('click', () => {
            loadAnnotationImage(currentAnnotationImageIndex + 1);
        });

        addClassButton.addEventListener('click', () => {
            const newId = classTypes.length > 0 ? Math.max(...classTypes.map(c => c.id)) + 1 : 0;
            const newName = `Object ${newId}`;
            
            classTypes.push({
                id: newId,
                name: newName,
                color: colors[newId % colors.length]
            });
            
            activeClassId = newId;
            updateLegend();
            drawAnnotations();
        });

        undoButton.addEventListener('click', () => {
            drawnBoxes.pop();
            drawAnnotations();
            updateTrainButton();
        });

        clearBoxesButton.addEventListener('click', () => {
            if (window.confirm("Clear all boxes for THIS image?")) {
                drawnBoxes = [];
                drawAnnotations();
                updateTrainButton();
            }
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            checkServerStatus();
        });
    </script>
</body>
</html>